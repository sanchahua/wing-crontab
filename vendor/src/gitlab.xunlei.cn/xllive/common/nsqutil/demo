package main

import (
	"fmt"
	"github.com/nsqio/go-nsq"
	nsqutil "nsq/nsqutil"
	"time"
)

func main() {

	var lookupAddrs []string
	lookupAddrs = append(lookupAddrs, "10.10.109.15:9151")
	lookupAddrs = append(lookupAddrs, "10.10.132.107:9151")

	//启动消费者线程
	consume(lookupAddrs)
	//启动生产者线程
	producer(lookupAddrs)

	select {}

}

//生产者
func producer(lookupAddrs []string) {
	nsqdBussi, err := nsqutil.NewProducerBussi(lookupAddrs)
	if err != nil {
		fmt.Printf("[main] call NewProducer failed, err:%v", err)
		return
	}

	//启动定时任务,定时检测是否有新的可用nsqd节点，并建立连接
	cronTask := nsqutil.NewOrderCrontab(10, nsqdBussi)
	cronTask.Start()

	//按照时间间隔向nsqd发送消息
	go func() {
		for {
			nsqdBussi.Publish("testone", "[nsq producer] hello nsq util")
			time.Sleep(time.Millisecond * 1000)
		}
	}()
}

//生产者消费者
func consume(lookupAddrs []string) error {
	config := nsq.NewConfig()
	//设置的值必须大于等于nsqd的节点数,默认只消费一个节点
	config.MaxInFlight = 10

	//设置订阅的topic,自身的channel
	c, err := nsq.NewConsumer("testone", "consum", config)
	if err != nil {
		return err
	}
	//注册自己的消费逻辑方法
	hand := func(msg *nsq.Message) error {
		fmt.Println(string(msg.Body), " src addr:", msg.NSQDAddress)
		return nil
	}
	c.AddHandler(nsq.HandlerFunc(hand))
	if err := c.ConnectToNSQLookupds(lookupAddrs); err != nil {
		fmt.Println("call ConnectToNSQLookupds failed:", err)
		return err
	}
	return nil
}
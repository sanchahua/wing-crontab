// Code generated by protoc-gen-go.
// source: proto/xlsoa/core/certificate.proto
// DO NOT EDIT!

/*
Package xlsoa_core is a generated protocol buffer package.

It is generated from these files:
	proto/xlsoa/core/certificate.proto

It has these top-level messages:
	AuthorizeRequest
	AuthorizeResponse
	SyncKeyRequest
	SyncKeyResponse
	Key
*/
package xlsoa_core

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CertificateResult int32

const (
	// - 成功
	CertificateResult_OK CertificateResult = 0
	// - 没有授权
	// 申请的一组Scope，如果全部都没有授权会返回这个错误
	//     Note: 如果部分授权，并不会返回这个错误。实际获取到的权限在AccessToken里面有描述。
	CertificateResult_ERR_AUTHORIZE CertificateResult = 404
	// 非法访问
	CertificateResult_ERR_AUTHENTICATE CertificateResult = 405
	// - 内部错误
	CertificateResult_ERR_INTERNAL CertificateResult = 500
)

var CertificateResult_name = map[int32]string{
	0:   "OK",
	404: "ERR_AUTHORIZE",
	405: "ERR_AUTHENTICATE",
	500: "ERR_INTERNAL",
}
var CertificateResult_value = map[string]int32{
	"OK":               0,
	"ERR_AUTHORIZE":    404,
	"ERR_AUTHENTICATE": 405,
	"ERR_INTERNAL":     500,
}

func (x CertificateResult) String() string {
	return proto.EnumName(CertificateResult_name, int32(x))
}
func (CertificateResult) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type AuthorizeRequest struct {
	// - 授权类型
	// 预留字段，暂时没用
	GrantType string `protobuf:"bytes,1,opt,name=grant_type,json=grantType" json:"grant_type,omitempty"`
	// - Assertion
	// jwt.Encode()之后的字符串
	// jwt里面描述了秘钥信息、申请授权的信息等。
	// 具体内容参考JWT相关的内容实现。
	Assertion string `protobuf:"bytes,2,opt,name=assertion" json:"assertion,omitempty"`
}

func (m *AuthorizeRequest) Reset()                    { *m = AuthorizeRequest{} }
func (m *AuthorizeRequest) String() string            { return proto.CompactTextString(m) }
func (*AuthorizeRequest) ProtoMessage()               {}
func (*AuthorizeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AuthorizeRequest) GetGrantType() string {
	if m != nil {
		return m.GrantType
	}
	return ""
}

func (m *AuthorizeRequest) GetAssertion() string {
	if m != nil {
		return m.Assertion
	}
	return ""
}

type AuthorizeResponse struct {
	// - 返回结果
	// 参考enum Result的定义
	Result CertificateResult `protobuf:"varint,1,opt,name=result,enum=xlsoa.core.CertificateResult" json:"result,omitempty"`
	// - 错误信息
	// result!=OK时返回的错误信息，方便跟踪定位
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	// - AccessToken
	// 授权的AccessToken字符串，Client端不用关系实际含义。
	AccessToken string `protobuf:"bytes,3,opt,name=access_token,json=accessToken" json:"access_token,omitempty"`
	// - Token类型
	// 预留字段，暂时没用
	TokenType string `protobuf:"bytes,4,opt,name=token_type,json=tokenType" json:"token_type,omitempty"`
	// - IDToken
	// 预留字段，暂时没用
	IdToken string `protobuf:"bytes,5,opt,name=id_token,json=idToken" json:"id_token,omitempty"`
	// - Token过期时间
	// 相对时间，单位为秒。
	// 表示该AccessToken可以使用的生命周期，Client端应该尽量在生命周期耗尽之前重新进行新的AccessToken申请。
	ExpiresIn int32 `protobuf:"varint,6,opt,name=expires_in,json=expiresIn" json:"expires_in,omitempty"`
}

func (m *AuthorizeResponse) Reset()                    { *m = AuthorizeResponse{} }
func (m *AuthorizeResponse) String() string            { return proto.CompactTextString(m) }
func (*AuthorizeResponse) ProtoMessage()               {}
func (*AuthorizeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AuthorizeResponse) GetResult() CertificateResult {
	if m != nil {
		return m.Result
	}
	return CertificateResult_OK
}

func (m *AuthorizeResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *AuthorizeResponse) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

func (m *AuthorizeResponse) GetTokenType() string {
	if m != nil {
		return m.TokenType
	}
	return ""
}

func (m *AuthorizeResponse) GetIdToken() string {
	if m != nil {
		return m.IdToken
	}
	return ""
}

func (m *AuthorizeResponse) GetExpiresIn() int32 {
	if m != nil {
		return m.ExpiresIn
	}
	return 0
}

type SyncKeyRequest struct {
	// 本地副本最新Key的版本号。如果没有任何版本则填0
	LatestVersion int32 `protobuf:"varint,1,opt,name=latest_version,json=latestVersion" json:"latest_version,omitempty"`
	// - Assertion
	// jwt.Encode()之后的字符串
	// jwt里面描述了秘钥信息、申请授权的信息等。
	// 具体内容参考JWT相关的内容实现。
	Assertion string `protobuf:"bytes,2,opt,name=assertion" json:"assertion,omitempty"`
}

func (m *SyncKeyRequest) Reset()                    { *m = SyncKeyRequest{} }
func (m *SyncKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*SyncKeyRequest) ProtoMessage()               {}
func (*SyncKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SyncKeyRequest) GetLatestVersion() int32 {
	if m != nil {
		return m.LatestVersion
	}
	return 0
}

func (m *SyncKeyRequest) GetAssertion() string {
	if m != nil {
		return m.Assertion
	}
	return ""
}

type SyncKeyResponse struct {
	// - 返回结果
	// 参考enum Result的定义
	Result CertificateResult `protobuf:"varint,1,opt,name=result,enum=xlsoa.core.CertificateResult" json:"result,omitempty"`
	// - 错误信息
	// result!=OK时返回的错误信息，方便跟踪定位
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	// - 最新的key列表
	Keys []*Key `protobuf:"bytes,3,rep,name=keys" json:"keys,omitempty"`
	// - 下次Sync的时间间隔
	// 单位秒
	NextInterval int32 `protobuf:"varint,4,opt,name=next_interval,json=nextInterval" json:"next_interval,omitempty"`
}

func (m *SyncKeyResponse) Reset()                    { *m = SyncKeyResponse{} }
func (m *SyncKeyResponse) String() string            { return proto.CompactTextString(m) }
func (*SyncKeyResponse) ProtoMessage()               {}
func (*SyncKeyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SyncKeyResponse) GetResult() CertificateResult {
	if m != nil {
		return m.Result
	}
	return CertificateResult_OK
}

func (m *SyncKeyResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *SyncKeyResponse) GetKeys() []*Key {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *SyncKeyResponse) GetNextInterval() int32 {
	if m != nil {
		return m.NextInterval
	}
	return 0
}

type Key struct {
	// 标记唯一Key的KeyId
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// 秘钥
	Secret string `protobuf:"bytes,2,opt,name=secret" json:"secret,omitempty"`
	// Key的版本号，实际上是该Key的创建时间(秒)
	Version int32 `protobuf:"varint,3,opt,name=version" json:"version,omitempty"`
	// Key剩余生命周期，单位秒
	TimeToLive int32 `protobuf:"varint,4,opt,name=time_to_live,json=timeToLive" json:"time_to_live,omitempty"`
}

func (m *Key) Reset()                    { *m = Key{} }
func (m *Key) String() string            { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()               {}
func (*Key) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Key) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Key) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

func (m *Key) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Key) GetTimeToLive() int32 {
	if m != nil {
		return m.TimeToLive
	}
	return 0
}

func init() {
	proto.RegisterType((*AuthorizeRequest)(nil), "xlsoa.core.AuthorizeRequest")
	proto.RegisterType((*AuthorizeResponse)(nil), "xlsoa.core.AuthorizeResponse")
	proto.RegisterType((*SyncKeyRequest)(nil), "xlsoa.core.SyncKeyRequest")
	proto.RegisterType((*SyncKeyResponse)(nil), "xlsoa.core.SyncKeyResponse")
	proto.RegisterType((*Key)(nil), "xlsoa.core.Key")
	proto.RegisterEnum("xlsoa.core.CertificateResult", CertificateResult_name, CertificateResult_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Certificate service

type CertificateClient interface {
	//
	// - 申请授权
	//
	// 针对授权结果的不同处理，Client端组件可以根据实际情况处理。以下是建议的处理
	//
	// 1. 成功，则更新本地AccessToken，并且用最新的AccessToken进行RPC Call
	// 2. Auth Call Error（例如网络通信失败）
	//         使用老的AccessToken进行RPC Call。待下次Auth重试。
	// 3. Auth Call 成功
	//         |ERR_AUTHORIZE|ERR_AUTHENTICATE: 返回上层Call失败，并且告知错误类型。不进行业务Service的RPC Call。
	//         ERR_INTERNAL                   : 使用老的AccessToken进行RPC Call。待下次重试
	//
	//
	Authorize(ctx context.Context, in *AuthorizeRequest, opts ...grpc.CallOption) (*AuthorizeResponse, error)
	// - 同步Key
	SyncKey(ctx context.Context, in *SyncKeyRequest, opts ...grpc.CallOption) (*SyncKeyResponse, error)
}

type certificateClient struct {
	cc *grpc.ClientConn
}

func NewCertificateClient(cc *grpc.ClientConn) CertificateClient {
	return &certificateClient{cc}
}

func (c *certificateClient) Authorize(ctx context.Context, in *AuthorizeRequest, opts ...grpc.CallOption) (*AuthorizeResponse, error) {
	out := new(AuthorizeResponse)
	err := grpc.Invoke(ctx, "/xlsoa.core.certificate/Authorize", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certificateClient) SyncKey(ctx context.Context, in *SyncKeyRequest, opts ...grpc.CallOption) (*SyncKeyResponse, error) {
	out := new(SyncKeyResponse)
	err := grpc.Invoke(ctx, "/xlsoa.core.certificate/SyncKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Certificate service

type CertificateServer interface {
	//
	// - 申请授权
	//
	// 针对授权结果的不同处理，Client端组件可以根据实际情况处理。以下是建议的处理
	//
	// 1. 成功，则更新本地AccessToken，并且用最新的AccessToken进行RPC Call
	// 2. Auth Call Error（例如网络通信失败）
	//         使用老的AccessToken进行RPC Call。待下次Auth重试。
	// 3. Auth Call 成功
	//         |ERR_AUTHORIZE|ERR_AUTHENTICATE: 返回上层Call失败，并且告知错误类型。不进行业务Service的RPC Call。
	//         ERR_INTERNAL                   : 使用老的AccessToken进行RPC Call。待下次重试
	//
	//
	Authorize(context.Context, *AuthorizeRequest) (*AuthorizeResponse, error)
	// - 同步Key
	SyncKey(context.Context, *SyncKeyRequest) (*SyncKeyResponse, error)
}

func RegisterCertificateServer(s *grpc.Server, srv CertificateServer) {
	s.RegisterService(&_Certificate_serviceDesc, srv)
}

func _Certificate_Authorize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthorizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificateServer).Authorize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xlsoa.core.certificate/Authorize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificateServer).Authorize(ctx, req.(*AuthorizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certificate_SyncKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificateServer).SyncKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xlsoa.core.certificate/SyncKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificateServer).SyncKey(ctx, req.(*SyncKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Certificate_serviceDesc = grpc.ServiceDesc{
	ServiceName: "xlsoa.core.certificate",
	HandlerType: (*CertificateServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Authorize",
			Handler:    _Certificate_Authorize_Handler,
		},
		{
			MethodName: "SyncKey",
			Handler:    _Certificate_SyncKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/xlsoa/core/certificate.proto",
}

func init() { proto.RegisterFile("proto/xlsoa/core/certificate.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 510 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x93, 0xdf, 0x6e, 0xd3, 0x30,
	0x14, 0xc6, 0x97, 0x66, 0xeb, 0xe8, 0xe9, 0x9f, 0xa5, 0x96, 0x40, 0xa1, 0xac, 0x52, 0xc9, 0x84,
	0x54, 0x71, 0xd1, 0x4a, 0x45, 0x3c, 0x40, 0x35, 0x2a, 0x51, 0x3a, 0xb5, 0x92, 0xc9, 0x90, 0xe0,
	0x26, 0x0a, 0xe9, 0x61, 0x58, 0xeb, 0xe2, 0x62, 0xbb, 0x55, 0xc3, 0x73, 0xc0, 0x35, 0x2f, 0xc0,
	0x43, 0xf1, 0x10, 0x3c, 0x00, 0xb2, 0xe3, 0x74, 0xe1, 0x9f, 0xb8, 0xe2, 0xd2, 0xbf, 0xcf, 0xfe,
	0xce, 0x39, 0x9f, 0x6d, 0x08, 0xd6, 0x82, 0x2b, 0x3e, 0xdc, 0xad, 0x24, 0x8f, 0x87, 0x09, 0x17,
	0x38, 0x4c, 0x50, 0x28, 0xf6, 0x8e, 0x25, 0xb1, 0xc2, 0x81, 0x11, 0x09, 0x18, 0x75, 0xa0, 0xd5,
	0x60, 0x01, 0xde, 0x78, 0xa3, 0xde, 0x73, 0xc1, 0x3e, 0x22, 0xc5, 0x0f, 0x1b, 0x94, 0x8a, 0x74,
	0x01, 0xae, 0x44, 0x9c, 0xaa, 0x48, 0x65, 0x6b, 0xf4, 0x9d, 0x9e, 0xd3, 0xaf, 0xd1, 0x9a, 0x21,
	0x61, 0xb6, 0x46, 0x72, 0x0a, 0xb5, 0x58, 0x4a, 0xed, 0xca, 0x53, 0xbf, 0x92, 0xab, 0x7b, 0x10,
	0x7c, 0x73, 0xa0, 0x5d, 0x72, 0x94, 0x6b, 0x9e, 0x4a, 0x24, 0x4f, 0xa1, 0x2a, 0x50, 0x6e, 0x56,
	0xca, 0xd8, 0xb5, 0x46, 0xdd, 0xc1, 0x6d, 0x0f, 0x83, 0xf3, 0xdb, 0x0e, 0xa9, 0xd9, 0x44, 0xed,
	0x66, 0xe2, 0xc3, 0xf1, 0x0d, 0x4a, 0x19, 0x5f, 0xa1, 0x2d, 0x54, 0x2c, 0xc9, 0x43, 0x68, 0xc4,
	0x49, 0x82, 0x52, 0x46, 0x8a, 0x5f, 0x63, 0xea, 0xbb, 0x46, 0xae, 0xe7, 0x2c, 0xd4, 0x48, 0x8f,
	0x61, 0xb4, 0x7c, 0x8c, 0xc3, 0xbc, 0x51, 0x43, 0xcc, 0x18, 0xf7, 0xe1, 0x0e, 0x5b, 0xda, 0xd3,
	0x47, 0xb9, 0x39, 0x5b, 0xee, 0x4f, 0xe2, 0x6e, 0xcd, 0x04, 0xca, 0x88, 0xa5, 0x7e, 0xb5, 0xe7,
	0xf4, 0x8f, 0x68, 0xcd, 0x92, 0x69, 0x1a, 0x5c, 0x42, 0xeb, 0x65, 0x96, 0x26, 0x33, 0xcc, 0x8a,
	0xc4, 0x1e, 0x41, 0x6b, 0x15, 0x2b, 0x94, 0x2a, 0xda, 0xa2, 0x90, 0x3a, 0x17, 0xc7, 0x1c, 0x6a,
	0xe6, 0xf4, 0x55, 0x0e, 0xff, 0x91, 0xdc, 0x57, 0x07, 0x4e, 0xf6, 0xbe, 0xff, 0x2b, 0xb7, 0x33,
	0x38, 0xbc, 0xc6, 0x4c, 0xfa, 0x6e, 0xcf, 0xed, 0xd7, 0x47, 0x27, 0x65, 0x3b, 0x5d, 0xd7, 0x88,
	0xe4, 0x0c, 0x9a, 0x29, 0xee, 0x54, 0xc4, 0x52, 0x85, 0x62, 0x1b, 0xaf, 0x4c, 0x78, 0x47, 0xb4,
	0xa1, 0xe1, 0xd4, 0xb2, 0x80, 0x81, 0x3b, 0xc3, 0x8c, 0xb4, 0xa0, 0xc2, 0x96, 0xf6, 0x91, 0x54,
	0xd8, 0x92, 0xdc, 0x83, 0xaa, 0xc4, 0x44, 0xa0, 0xb2, 0x95, 0xed, 0x4a, 0xb7, 0x54, 0x64, 0xe3,
	0x1a, 0xb7, 0x62, 0x49, 0x7a, 0xd0, 0x50, 0xec, 0x06, 0x23, 0xc5, 0xa3, 0x15, 0xdb, 0xa2, 0x2d,
	0x06, 0x9a, 0x85, 0xfc, 0x82, 0x6d, 0xf1, 0xf1, 0x6b, 0x68, 0xff, 0x36, 0x2b, 0xa9, 0x42, 0x65,
	0x31, 0xf3, 0x0e, 0x08, 0x81, 0xe6, 0x84, 0xd2, 0x68, 0x7c, 0x19, 0x3e, 0x5f, 0xd0, 0xe9, 0x9b,
	0x89, 0xf7, 0xc9, 0x25, 0x77, 0xc1, 0x2b, 0xd8, 0x64, 0x1e, 0x4e, 0xcf, 0xc7, 0xe1, 0xc4, 0xfb,
	0xec, 0x92, 0x36, 0x34, 0x34, 0x9e, 0xce, 0xc3, 0x09, 0x9d, 0x8f, 0x2f, 0xbc, 0xef, 0xee, 0xe8,
	0x8b, 0x03, 0xf5, 0xd2, 0x0f, 0x21, 0x2f, 0xa0, 0xb6, 0x7f, 0xbd, 0xe4, 0xb4, 0x1c, 0xcf, 0xaf,
	0xdf, 0xa4, 0xd3, 0xfd, 0x8b, 0x9a, 0x5f, 0x5d, 0x70, 0x40, 0x9e, 0xc1, 0xb1, 0xbd, 0x4f, 0xd2,
	0x29, 0xef, 0xfd, 0xf9, 0xf1, 0x74, 0x1e, 0xfc, 0x51, 0x2b, 0x5c, 0xde, 0x56, 0xcd, 0xa7, 0x7d,
	0xf2, 0x23, 0x00, 0x00, 0xff, 0xff, 0x63, 0x7f, 0xa3, 0x50, 0xda, 0x03, 0x00, 0x00,
}
